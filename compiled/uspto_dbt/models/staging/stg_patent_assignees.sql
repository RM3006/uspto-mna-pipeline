

WITH
    source AS (
        SELECT * FROM uspto_db.raw.patent_assignment_xml
        QUALIFY
            ROW_NUMBER()
                OVER (PARTITION BY MD5(xml_content) ORDER BY loaded_at DESC)
            = 1
    ),

    -- Flatten the XML: Explode the "patent-assignees" list into rows
    flattened AS (
        SELECT
        -- Retain the keys so we can join back to the main table later
            GET(
                XMLGET(XMLGET(source.xml_content, 'assignment-record'), 'reel-no'), '$'
            )::VARCHAR AS reel_number,
            GET(
                XMLGET(XMLGET(source.xml_content, 'assignment-record'), 'frame-no'),
                '$'
            )::VARCHAR AS frame_number,
            assignee.value AS assignee_node

        FROM source,
            -- LATERAL FLATTEN goes into the array and creates a row for each item in patent assignees
            LATERAL FLATTEN(
                -- The list to explode
                input => XMLGET(source.xml_content, 'patent-assignees'):"$",
                outer => true -- Keep the record even if the list is empty
            ) AS assignee
    )

SELECT
    reel_number,
    frame_number,

    -- Extract details from the specific assignee node
    
CASE
    WHEN IS_ARRAY(assignee_node) THEN
    uspto_db.raw.get_xml_array_value(assignee_node, 'name')
    ELSE GET(XMLGET(assignee_node, 'name'),'$')::VARCHAR
END

 AS assignee_name,
    
CASE
    WHEN IS_ARRAY(assignee_node) THEN
    uspto_db.raw.get_xml_array_value(assignee_node, 'city')
    ELSE GET(XMLGET(assignee_node, 'city'),'$')::VARCHAR
END

 AS city,
    
CASE
    WHEN IS_ARRAY(assignee_node) THEN
    uspto_db.raw.get_xml_array_value(assignee_node, 'state')
    ELSE GET(XMLGET(assignee_node, 'state'),'$')::VARCHAR
END

 AS state,
    
CASE
    WHEN IS_ARRAY(assignee_node) THEN
    uspto_db.raw.get_xml_array_value(assignee_node, 'country-name')
    ELSE GET(XMLGET(assignee_node, 'country-name'),'$')::VARCHAR
END

 AS country

FROM flattened
-- 1. Keep if it is a JSON Array (valid Newpark case)
-- 2. Keep if it is valid XML (valid Midea case)
-- 3. Drop if it is "Trash" (random strings/numbers generated by flattening Objects)
WHERE
    (IS_ARRAY(assignee_node) = true)
    OR (CHECK_XML(assignee_node::VARCHAR) IS null)