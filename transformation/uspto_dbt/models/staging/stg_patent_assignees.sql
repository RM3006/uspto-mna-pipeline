{{ config(materialized='table') }}

WITH source AS (
    SELECT * FROM {{ source('uspto', 'patent_assignment_xml') }}
),

-- Flatten the XML: Explode the "patent-assignees" list into rows
flattened AS (
    SELECT
        -- Retain the keys so we can join back to the main table later
        GET( XMLGET( XMLGET(xml_content, 'assignment-record'), 'reel-no' ), '$' )::VARCHAR AS reel_number,
        GET( XMLGET( XMLGET(xml_content, 'assignment-record'), 'frame-no' ), '$' )::VARCHAR AS frame_number,
        assignee.value as assignee_node

    FROM source,
    -- LATERAL FLATTEN goes into the array and creates a row for each item in patent assignees
    LATERAL FLATTEN(
        input => XMLGET(xml_content, 'patent-assignees'):"$", -- The list to explode
        outer => true -- Keep the record even if the list is empty
    ) AS assignee

    QUALIFY ROW_NUMBER() OVER (PARTITION BY MD5(xml_content) ORDER BY loaded_at DESC) = 1
)

SELECT
    reel_number,
    frame_number,
    
    -- Extract details from the specific assignee node
    {{get_xml_value('assignee_node','name')}} as assignee_name,
    {{get_xml_value('assignee_node','city')}} as city,
    {{get_xml_value('assignee_node','state')}} as state,
    {{get_xml_value('assignee_node','country-name')}} as country

FROM flattened
-- 1. Keep if it is a JSON Array (valid Newpark case)
-- 2. Keep if it is valid XML (valid Midea case)
-- 3. Drop if it is "Trash" (random strings/numbers generated by flattening Objects)
WHERE
    (IS_ARRAY(assignee_node) = TRUE) 
    OR (CHECK_XML(assignee_node::VARCHAR) IS NULL)
