{{ config(materialized='table') }}

WITH
    source AS (
        SELECT * FROM {{ source('uspto', 'patent_assignment_xml') }}
        QUALIFY
            ROW_NUMBER()
                OVER (PARTITION BY MD5(xml_content) ORDER BY loaded_at DESC)
            = 1
    ),

    -- Flatten the XML: Explode the "patent-assignees" list into rows
    flattened AS (
        SELECT
        -- Retain the keys so we can join back to the main table later
            GET(
                XMLGET(XMLGET(source.xml_content, 'assignment-record'), 'reel-no'), '$'
            )::VARCHAR AS reel_number,
            GET(
                XMLGET(XMLGET(source.xml_content, 'assignment-record'), 'frame-no'),
                '$'
            )::VARCHAR AS frame_number,
            assignee.value AS assignee_node

        FROM source,
            -- LATERAL FLATTEN goes into the array and creates a row for each item in patent assignees
            LATERAL FLATTEN(
                -- The list to explode
                input => XMLGET(source.xml_content, 'patent-assignees'):"$",
                outer => true -- Keep the record even if the list is empty
            ) AS assignee
    )

SELECT
    reel_number,
    frame_number,

    -- Extract details from the specific assignee node
    {{ get_xml_value('assignee_node','name') }} AS assignee_name,
    {{ get_xml_value('assignee_node','city') }} AS city,
    {{ get_xml_value('assignee_node','state') }} AS state,
    {{ get_xml_value('assignee_node','country-name') }} AS country

FROM flattened
-- 1. Keep if it is a JSON Array (valid Newpark case)
-- 2. Keep if it is valid XML (valid Midea case)
-- 3. Drop if it is "Trash" (random strings/numbers generated by flattening Objects)
WHERE
    (IS_ARRAY(assignee_node) = true)
    OR (CHECK_XML(assignee_node::VARCHAR) IS null)
